# CFG Generation Architecture - Using Official Clang/Clang++ Libraries

## ✅ Confirmation: YES, Using Official Clang Libraries

The entire static analysis pipeline uses **official Clang/Clang++ libraries** (libclang/LLVM), NOT custom implementations.

## Complete Pipeline

```
┌─────────────────────────────────────────────────────────────┐
│  1. cfg-exporter (C++ Tool - Using Official Clang Libraries) │
├─────────────────────────────────────────────────────────────┤
│                                                               │
│  - Compiled with libclang and LLVM                           │
│  - Uses: clang::CFG::buildCFG()                             │
│    └─ Official Clang Control Flow Graph builder            │
│    └─ Same as C++ compiler uses internally                 │
│                                                               │
│  - Uses: clang::RecursiveASTVisitor                         │
│    └─ Official Clang AST traversal                         │
│    └─ Traverses Abstract Syntax Tree from clang parser     │
│                                                               │
│  - Uses: clang::tooling::buildASTFromCodeWithArgs()        │
│    └─ Official Clang tooling                               │
│    └─ Builds AST with explicit compiler arguments          │
│                                                               │
│  Output: JSON with CFG blocks, statements, control flow     │
└────────────────────────────────────────────────────────────┘
                         ↓
┌─────────────────────────────────────────────────────────────┐
│  2. ClangASTParser.ts (TypeScript - JSON Conversion)        │
├─────────────────────────────────────────────────────────────┤
│                                                               │
│  - Parses JSON output from cfg-exporter                     │
│  - Converts to ASTNode format (preserves Clang structure)   │
│  - Creates: { kind: 'FunctionDecl', inner: [CFGBlock...] }  │
│                                                               │
└────────────────────────────────────────────────────────────┘
                         ↓
┌─────────────────────────────────────────────────────────────┐
│  3. EnhancedCPPParser.ts (TypeScript - CFG Extraction)      │
├─────────────────────────────────────────────────────────────┤
│                                                               │
│  - Extracts CFGBlock nodes from ASTNode                     │
│  - Builds FunctionCFG with:                                 │
│    • Block IDs, labels, entry/exit flags                    │
│    • Statements for each block                              │
│    • Predecessors and successors (control flow)             │
│                                                               │
└────────────────────────────────────────────────────────────┘
                         ↓
┌─────────────────────────────────────────────────────────────┐
│  4. DataflowAnalyzer.ts (TypeScript - Analysis Passes)      │
├─────────────────────────────────────────────────────────────┤
│                                                               │
│  - Liveness Analysis (which variables are live)             │
│  - Reaching Definitions (which definitions reach each point)│
│  - Taint Analysis (track potentially malicious data)        │
│                                                               │
│  All analyses work on the CFG generated by Clang            │
│                                                               │
└────────────────────────────────────────────────────────────┘
                         ↓
┌─────────────────────────────────────────────────────────────┐
│  5. CFGVisualizer.ts (TypeScript - Visualization)           │
├─────────────────────────────────────────────────────────────┤
│                                                               │
│  - Renders CFG using vis-network library                    │
│  - Displays nodes and edges from Clang's CFG               │
│  - Shows analysis results (liveness, definitions, etc.)     │
│                                                               │
└────────────────────────────────────────────────────────────┘
```

## Current Status

✅ **CFG Extraction Working**
- All 3 functions extracted: `factorial`, `processArray`, `main`
- Blocks extracted with correct IDs, labels, and control flow edges
- Statements properly assigned to blocks
- Entry and exit blocks correctly identified

## Key Files Using Official Clang

### cpp-tools/cfg-exporter/cfg-exporter.cpp (Lines 24-40)
```cpp
bool VisitFunctionDecl(FunctionDecl *Func) {
    if (!Func->hasBody()) {
        return true;
    }
    
    Stmt *Body = Func->getBody();
    auto &SM = Context.getSourceManager();
    
    // Skip functions not in main file
    if (!SM.isInMainFile(Func->getLocation())) {
        return true;
    }
    
    // ✅ Official Clang CFG builder
    std::unique_ptr<CFG> cfg = CFG::buildCFG(Func, Body, &Context, CFG::BuildOptions());
    if (!cfg) {
        return true;
    }
    // ... export CFG to JSON
}
```

### cpp-tools/cfg-exporter/cfg-exporter.cpp (Main - Lines 191-195)
```cpp
// ✅ Official Clang tooling - builds AST from code with args
auto AST = clang::tooling::buildASTFromCodeWithArgs(
    Source,
    CompilerArgs,
    SourceFile
);
```

## Why This Is Correct

1. **`clang::CFG::buildCFG()`** - The SAME function used by Clang's static analyzer
2. **`clang::RecursiveASTVisitor`** - Used by all Clang-based tools
3. **`clang::tooling::buildASTFromCodeWithArgs()`** - Cross-platform, environment-agnostic
4. **Official Clang compiler args** - `-std=c++17`, system include paths discovered by Clang

## To Verify CFG Correctness

Check the logs for block structure (with latest code):
```
- Added block 4 (Entry) - successors: [3], predecessors: []
- Added block 3 (B3) - successors: [1,2], predecessors: [4]
- Added block 1 (B1) - successors: [0], predecessors: [3]
- Added block 2 (B2) - successors: [0], predecessors: [3]
- Added block 0 (Exit) - successors: [], predecessors: [1,2]
```

This shows:
- **Entry (4)** splits to **B3 (3)**
- **B3** branches to **B1** (if true) or **B2** (if false)
- Both **B1** and **B2** converge to **Exit (0)**

This is the correct CFG structure for an if-else statement!

## Summary

✅ **Static analysis pipeline uses official Clang/Clang++ libraries throughout**
- CFG generation: Official Clang CFG builder
- AST parsing: Official Clang tooling
- Dataflow analysis: Custom implementation on Clang-generated CFG
- Visualization: vis-network rendering

The CFG is theoretically sound and generated by the same machinery as the C++ compiler.

